<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sort Comparison</title>
    <link rel="stylesheet" href="assets/css/style.css">
</head>

<body>

    <section id="sorting-section">
        <section id="leftArrayContainer">
            <div id="leftArray">
            </div>
        </section>
        <div id="settingsArea">
            <div id="leftArrayAlgorithmChoose">
                <button id="bubbleSort">BUBBLE</button>
                <button id="selectionSort">SELECTION</button>
                <button id="insertionSort">INSERTION</button>
                <button id="mergeSort">MERGE</button>
                <button id="quickSort">QUICK</button>
            </div>

            <div id="settingsContainer">
                <div id="themeSwitch">
                    <button id="themeButton" class="darkTheme"><img src="assets/img/outlined-moon-icon.svg"></button>
                </div>
                <section id="lengthChooseContainer">
                    <h2>Tamanho da lista</h2>
                    <input type="range" class="lengthChoose" min="2" max="200" value="100">
                    <input type="text" id="lengthInput" value="100"></text>
                    <button class="createArrayButton">Gerar nova lista</button>
                </section>
                <section id="timeMultiplierContainer">
                    <h2>Multiplicador de tempo</h2>
                    <div>
                        <button id="timeMultiplier25">0.25x</button>
                        <button id="timeMultiplier50">0.50x</button>
                        <button id="timeMultiplier75">0.75x</button>
                        <button id="timeMultiplier1" class="selectedTime">1.0x</button>
                    </div>
                </section>
                <button id="sortButton">Comparar</button>
            </div>
            <div id="rightArrayAlgorithmChoose">
                <button id="bubbleSort">BUBBLE</button>
                <button id="selectionSort">SELECTION</button>
                <button id="insertionSort">INSERTION</button>
                <button id="mergeSort">MERGE</button>
                <button id="quickSort">QUICK</button>
            </div>
        </div>

        <section id="rightArrayContainer">
            <div id="rightArray">
            </div>
        </section>

        <div id="scrollArea">
            <a href="#infoSection" id="scrollArrow"><img src="assets/img/scroll-arrow.svg" alt=""></img></a>
        </div>


    </section>


    <section id="infoSection">
        <div id="infoContainer">
            <div id="infoAlgorithmChoose">
                <button id="infoBubble" class="selectedInfo">BUBBLE</button>
                <button id="infoSelection">SELECTION</button>
                <button id="infoInsertion">INSERTION</button>
                <button id="infoMerge">MERGE</button>
                <button id="infoQuick">QUICK</button>
            </div>



            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->



            <div id="infoContentBubble">
                <br>
                <p>Existem diversos algoritmos para colocar os elementos de uma lista em ordem. Um dos mais simples e mais implementados é o <span>Bubble Sort</span>. Nele, trocamos todos os elementos adjacentes que estejam fora de ordem:</p>
                <br>
                <img src="assets/img/bubble-gif.gif" alt="Bubble Sort GIF">
                <p>________________________________________________________________</p>
                <br>
                <p>Podemos ver que agora que o algoritmo foi concluído, a lista de números está ordenada.</p>
                <br>
                <p>Em JavaScript:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> bubbleSort(l){
  <a class="blue">const</a> n = l.<a class="blue">length</a>;
  
  <a class="blue">for</a> (<a class="blue">let</a> i = 0; i < n; i++){
    <a class="blue">for</a> (<a class="blue">let </a>j = 0; j < n-i-1; j++){
      <a class="blue">if</a> (l[j] > l[j+1]){
        [l[j], l[j+1]] = [l[j+1], l[j]];
      }
    }
  }
}
                    </pre>
                </div>
                <br>
                <p>Ao invés disso, podemos parar a execução do algoritmo quando percebermos que ele já está ordenado:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> bubbleSort2(l){
  <a class="blue">const</a> n = l.<a class="blue">length</a>

  <a class="blue">for</a> (<a class="blue">let</a> i = 0; i < n; i++){
    <a class="blue">let</a> switch = false;
    <a class="blue">for</a> (<a class="blue">let </a>j = 0; j < n-i-1; j++){
      <a class="blue">if</a> (l[j] > l[j+1]){
        [l[j], l[j+1]] = [l[j+1], l[j]];
        switch = true;
      }
    }
    <a class="blue">if</a> (<a class="blue">!</a>switch){
      <a class="blue">return</a>
    }
  }
}
                    </pre>
                </div>
                <br>
                <p>A complexidade do Bubble Sort é <i>O(n<sup>2</sup>)</i></p>
                <br>
            </div>



            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->



            <div id="infoContentSelection">
                <br>
                <p>
                    Para colocar os elementos de uma lista em ordem crescente, o método <span>Selection Sort</span> vai
                    selecionando o menor elemento da lista e inserindo-o na frente dos demais, repetidamente. O
                    algoritmo mantém a lista dividida em duas partes ao longo de sua execução:
                </p>
                <br>
                <ul>
                    <li>Os elementos já ordenados, no início da lista.</li>
                    <li>O restante da lista a ser ordenada.</li>
                </ul>
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>Exemplo:</p>
                <br>
                <img src="assets/img/selection-gif.gif" alt="Selection Sort GIF">
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>Em JavaScript:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> selectionSort(l){
  <a href=""><a class="blue">for</a> (<a class="blue">let</a> i = 0; i < l.<a class="blue">length</a>; i++){
    <a class="blue">let</a> smallerPos = i
    <a class="blue">for</a> (<a class="blue">let</a> j = i + 1; j < l.<a class="blue">length</a>;j++):
      <a class="blue">if</a> (l[smallerPos] > l[j]){
        smallerPos = j
        }
      }
    [l[i], l[smallerPos]] = [l[smallerPos], l[i]]
  }
}
                    </pre>
                </div>
                <br>
                <p>
                    Um vantagem deste método é que ele nunca troca dois elementos de posição mais do que <i>O(n)</i>
                    vezes.
                </p>
                <br>
            </div>



            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->



            <div id="infoContentInsertion">
                <br>
                <p>O método <span>Insertion Sort</span> é um método simples de ordenação, que simula a forma como ordenamos as cartas de um baralho:</p>
                <br>
                <ol>
                    <li>Inicialmente, escolho um elemento qualquer e insiro numa nova sequência, que por enquanto está ordenada.</li>
                    <li>Em seguida, escolho um outro elemento qualquer dentre os que faltam, e insiro-o ordenadamente na lista que contém os elementos já ordenados.</li>
                    <li>Caso ainda haja elementos a serem inseridos, volte ao passo 2.</li>
                </ol>
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>Exemplo:</p>
                <br>
                <img src="assets/img/insertion-gif.gif" alt="Insertion Sort GIF">
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>Em JavaScript:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> insertionSort(l){

  <a class="blue">for</a> (<a class="blue">let</a> k = 1; k < l.<a class="blue">length</a>; k++){
    <a class="blue">const</a> elem = l[k];
    <a class="blue">let</a> pos = k - 1;

    <a class="blue">while</a> (pos >== 0) <a class="blue">&&</a> l[pos] > elem){
      l[pos + 1] = l[pos];
      pos = pos - 1;
    }

    l[pos + 1] = elem;
  }
}
                    </pre>
                </div>
                <br>
            </div>



            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->



            <div id="infoContentMerge">
                <br>
                <p>O método de ordenação <span>Merge Sort</span> é um algoritmo recursivo mais eficiente que o Bubble, Selection e Insertion Sort. A complexidade dele é <i>O(n × lg n)</i>, enquanto os outros três são <i>O(n<sup>2</sup>)</i>. Quando a complexidade de um algoritomo é <i>O(f(n))</i>, significa que o tempo é sempre proporcional a <i>f(n)</i> (no melhor caso, no pior caso e na média).</p>
                <p>O algoritmo vai dividindo a sequência ao meio, até que haja apenas 1 elemento. Depois, vai mesclando as subsequências de forma que se mantenham ordenadas.</p>
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>Exemplo:</p>
                <br>
                <img src="assets/img/merge-gif.gif" alt="Merge Sort GIF">
                <br>
                <p>Resumindo, os passos acima, a ideia do algoritmo é a seguinte:</p>
                <br>
                <ol>
                    <li>Se houver no máximo um elemento na sequência, ela está ordenada.</li>
                    <li>Se não, encontre o meio da sequência e divida-a em duas metades.</li>
                    <li>Recursivamente, ordene a metade da esquerda usando o próprio Merge Sort.</li>
                    <li>Recursivamente, ordene a metade da direita usando o próprio Merge Sort.</li>
                    <li>Junte as duas metades, de forma que o resultado se mantenha ordenado.</li>
                </ol>
                <br>
                <p>________________________________________________________________</p>
                <br>
                <p>O algoritmo em JavaScript é:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> mergeSort(arr){
  <a class="blue">if </a>(arr.<a class="blue">length</a> > 1){
    <a class="blue">const</a> mid = arr.<a class="blue">length</a> // 2;
    <a class="blue">const</a> leftArray = arr.<a class="blue">slice</a>(0, mid);
    <a class="blue">const</a> rightArray = arr.<a class="blue">slice</a>(mid + 1);

    <a class="blue">mergeSort</a>(leftArray);
    <a class="blue">mergeSort</a>(righttArray);
    
    <a class="blue">merge</a>(arr, leftArray, rightArray);
  }
}
                    </pre>
                </div>
                <br>
                <p>Para que ele funcione, é necessário criar uma função auxiliar que recebe duas listas ordenadas, e salva seus elementos em uma sequência ordenada:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> merge(arr, leftArray, rightArray){
  <a class="blue">let</a> i = 0;
  <a class="blue">let</a> j = 0;
  <a class="blue">let</a> k = 0;

  <a class="blue">while</a> (i < leftArray.<a class="blue">length &&</a> j < rightArray.<a class="blue">length</a>){
    <a class="blue">if </a>(leftArray[i] < rightArray[j]){
        arr[k] = leftArray[i];
        i++;
    } <a class="blue">else</a>{
        arr[k] = rightArray[j];
        j++;
    }
    k++;
  }

  <a class="blue">while</a> (i < leftArray.<a class="blue">length</a>){
    arr[k] = leftArray[i];
    i++;
    k++;
  }

  <a class="blue">while</a> (j < rightArray.<a class="blue">length</a>){
    arr[k] = rightArray[j];
    j++;
    k++;
  } 
}
                    </pre>
                </div>
                <br>
            </div>



            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->
            <!--#  ===========================================================================================-->



            <div id="infoContentQuick">
                <br>
                <p>Assim como o Merge Sort, o <span>Quick Sort</span> também divide o problema em problemas menores. Como vantagem, ele não necessita de armazenamento exxtra para criar sublistas. Como desvantagem, sua eficiência pode ser prejudicada se a escolha do pivô for ruim.</p>
                <p>O algoritmo seleciona um elemento qualquer como o pivô. Em seguida, divide a sequência entre os menores que o pivô à sua esquerda e os maiores à direita. Em seguida, ordena cada sublista recursivamente.</p>
                <br>
                <p>No exemplo a seguir, fazemos toda a ordenação de uma sequência utilizando o Quick Sort:</p>
                <br>
                <img src="assets/img/quick-gif.gif" alt="Quick Sort GIF">
                <br>
                <p>Em JavaScript:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> quickSort(arr, inf, sup){
  <a class="blue">if</a> (inf < sup){
    <a class="blue">const</a> pos = <a class="blue">particao</a>(arr, inf, sup);
    <a class="blue">quickSort</a>(arr, inf, pos - 1);
    <a class="blue">quickSort</a>(arr, pos + 1, sup);
  }
}
                    </pre>
                </div>
                <br>
                <p>Para que o algoritmo funcione, a função auxiliar "partition" realiza a separacao entre menores e maiores, e retorna o índice do pivô após a partição:</p>
                <br>
                <div class="codeContainer">
                    <pre>
<a class="blue">function</a> partition(arr, inf, sup){
  <a class="blue">const</a> pivot = arr[inf];
  <a class="blue">let</a> i = inf + 1;
  <a class="blue">let</a> j = sup;

  <a class="blue">while</a> (i <== j){
    <a class="blue">while</a> (i <== j <a class="blue">&&</a> arr[i] <== pivot){
        i++;
    }
    <a class="blue">while</a> (j >== i <a class="blue">&&</a> arr[j] > pivot){
        j--;
    }
    <a class="blue">if</a> (i < j){
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  [arr[inf], arr[j]] = [arr[j], arr[inf]];
  <a class="blue">return</a> j;
}
                    </pre>
                </div>
                <br>
            </div>

        </div>
    </section>

    <footer>
        <div id="footerContent">
            <div id="creditsContainer">
                <h1>Jhonata Polito</h1>
                <p>Este site foi desenvolvido com o intuito de aprimorar minhas habilidades. Todo o código está dísponivel no meu <a href="https://github.com/jhonataplt/sort-comparison" id="repositoryLink" target="_blank">GitHub</a>.</p>
                <p>© Jhonata Polito <a href="https://jhonataplt.github.io/sort-comparison/">jhonataplt.github.io/sort-comparison/</a></p>
            </div>
            <div class="verticalSeparator"></div>
            <div id="contactsContainer">
                <h1>Minhas redes</h1>
                <div id="contactsGrid">
                    <a href="" target="_blank"><img src="assets/img/globe-icon.svg">Website</a>
                    <a href="https://www.linkedin.com/in/jhonatapolito/" target="_blank"><img src="assets/img/linkedin-icon.svg">Linkedin</a>
                    <a href="https://github.com/jhonataplt" target="_blank"><img src="assets/img/github-icon.svg">Github</a>
                    <a href="mailto:jhonata.demuner@gmail.com" target="_blank"><img src="assets/img/email-icon.svg">E-mail</a>
                </div>
                <p>jhonata.demuner@gmail.com</p>
            </div>
            <div class="verticalSeparator"></div>
            <div id="subscribeArea">
                <h1>Fique por dentro</h1>
                <form action="https://formspree.io/f/xrgvbjop" method="POST" >
                    <input type="email" name="email" id="emailInput" placeholder="E-mail" required>
                    <button type="submit" id="submitButton"><img src="assets/img/send-icon.svg"></button>
                </form>
                <p>Se inscreva para ser avisado dos meus novos projetos</p>
            </div>
           
        </div>
    </footer>

    <script src="assets/js/main.js"></script>
</body>

</html>